# Copyright: (c) 2020, Jordan Borean (@jborean93) <jborean93@gmail.com>
# MIT License (see LICENSE or https://opensource.org/licenses/MIT)

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

import base64
import logging
from typing import List, Optional

from spnego.exceptions import (
    FeatureMissingError,
)

from spnego._context import (
    ContextProxy,
    ContextReq,
)

from spnego._spnego import (
    NegState,
    NegTokenInit,
    NegTokenInit2,
    NegTokenResp,
    pack_mech_type_list,
    pack_neg_token_init,
    pack_neg_token_init2,
    pack_neg_token_resp,
    unpack_neg_token,
)

from spnego._text import (
    to_bytes,
    to_text,
)

from spnego.gssapi import GSSAPIProxy

from spnego.ntlm import NTLMProxy


log = logging.getLogger(__name__)


class NegotiateProxy(ContextProxy):
    """A context wrapper for a Python managed SPNEGO context.

    This is a context that can be used on Linux to generate SPNEGO tokens based on the raw Kerberos or NTLM tokens
    generated by gssapi or ntlm-auth. This is used as a fallback if gssapi is not available or cannot generate SPNEGO
    tokens.

    Args:

    Attributes:
        context (Optional[ContextProxy]): The internal context that this proxy is using to generate the raw tokens.
    """

    def __init__(self, username=None, password=None, hostname='unspecified', service='host', channel_bindings=None,
                 delegate=False, mutual_auth=True, replay_detect=True, sequence_detect=True, confidentiality=True,
                 integrity=True, usage='initiate', protocol='negotiate'):
        super(NegotiateProxy, self).__init__(username, password, hostname, service, channel_bindings, delegate,
                                             mutual_auth, replay_detect, sequence_detect, confidentiality, integrity,
                                             usage, protocol)

        self.context = None  # type: Optional[ContextProxy]

        self._complete = False  # type: bool
        self._mech_list = []  # type: List[str]
        self._mech = None  # type: Optional[str]

        self._init_sent = False  # type: bool
        self._mech_sent = False  # type: bool
        self._mic_sent = False  # type: bool
        self._mic_recv = False  # type: bool
        self._mic_required = False  # type: bool

    @classmethod
    def available_protocols(cls, feature_flags=0):
        return [u'negotiate']

    @classmethod
    def iov_available(cls):
        return GSSAPIProxy.iov_available()

    @property
    def complete(self):
        return self._complete

    @property
    def negotiated_protocol(self):
        return self.context.negotiated_protocol

    @property
    def session_key(self):
        return self.context.session_key

    @property
    def requires_mech_list_mic(self):
        return self.context.requires_mech_list_mic

    def create_spn(self, service, principal):
        return self.context.create_spn

    def step(self, in_token=None):
        # Step 1. Process SPNEGO mechs
        mech_token_in = None
        mech_list_mic = None

        if in_token:
            in_token = unpack_neg_token(in_token)

            mech_list_mic = in_token.mech_list_mic

            # Windows can send NegTokenInit2 (seen with SMB) token if it initiated the auth process, the fields we care
            # about are still the same as NegTokenInit.
            if isinstance(in_token, (NegTokenInit, NegTokenInit2)):
                self._spnego_context.init_sent = True
                mech_token_in = in_token.mech_token

                mech_types = in_token.mech_types
                new_list = []
                for oid in mech_types:
                    if oid in self._spnego_context.mech_list:
                        new_list.append(oid)

                # Could not find a common mechanism with the server
                if not new_list:
                    raise Exception("Failed to negotiated negotiation protocol with server")

                if self._spnego_context.mech != new_list[0]:
                    a = ''  # TODO: adjust list accordingly and rebuild the context.

            elif isinstance(in_token, NegTokenResp):
                mech_token_in = in_token.response_token

                # If we have received the supported_mech then we don't need to send our own.
                if in_token.supported_mech:
                    # TODO: verify that the supported_mech is the one we originally sent.
                    self._spnego_context.mech_sent = True

                # Raise exception if we are rejected and have no error info (mechToken) that will give us more info.
                if in_token.neg_state == NegState.reject and not mech_token_in:
                    raise Exception("Received SPNEGO rejection")

                if in_token.neg_state == NegState.request_mic:
                    self._spnego_context.mic_required = True
                elif in_token.neg_state == NegState.accept_complete:
                    self._spnego_context.complete = True

        else:
            # We are starting the process and can build our own mech list
            a = ''
            #self._spnego_context = _SPNEGOContext(_KERBEROS_OID, _NTLM_OID)
            #self._spnego_context.inner_context = self._context

        # Step 2. Process the inner context tokens.
        mech_token_out = None
        if not self.context.complete:
            try:
                mech_token_out = self.context.step(in_token=mech_token_in)
            except GSSError as err:
                # TODO: Need the fallback from GSSAPI failing with Kerb to ntlm-auth if the first step fails
                raise err
            else:
                # NTLM has a special case where we need to tell it it's ok to generate the MIC and also determine if
                # it actually did set the MIC as that controls the mechListMIC for the SPNEGO token.
                if self.requires_mech_list_mic:
                    self._spnego_context.mic_required = True

        # Step 3. Process / generate the mechListMIC and return the new SPNEGO token.
        if mech_list_mic:
            self.verify(pack_mech_type_list(self._mech_list), mech_list_mic)
            self.reset_ntlm_crypto_state(outgoing=True)

            self._mic_required = True  # If we received a mechListMIC we need to send one back.
            self._mic_recv = True

        out_mic = None
        if self._mic_required and not self._mic_sent:
            out_mic = self.sign(pack_mech_type_list(self._mech_list))
            self.reset_ntlm_crypto_state()

            self._mic_sent = True

        out_token = None
        if not self._init_sent:
            self._init_sent = True

            build_func = pack_neg_token_init if self.usage == 'initiate' else pack_neg_token_init2
            out_token = build_func(self._mech_list, mech_token=mech_token_out, mech_list_mic=out_mic)

        elif not self.complete:
            # As per RFC 4178 - 4.2.2: supportedMech should only be present in the first reply from the target.
            # https://tools.ietf.org/html/rfc4178#section-4.2.2
            supported_mech = None
            if not self._mech_sent:
                supported_mech = self._mech
                self._mech_sent = True

            state = NegState.accept_incomplete

            if self.context.complete:
                if self._mic_sent and not self._mic_recv:
                    # TODO: request_mic for an acceptor should also be set if the preferred mech wasn't selected by the initiator
                    state = NegState.request_mic
                else:
                    state = NegState.accept_complete
                    self._complete = True

            out_token = pack_neg_token_resp(neg_state=state, response_token=mech_token_out,
                                            supported_mech=supported_mech, mech_list_mic=mech_list_mic)

        return out_token

    def wrap(self, data, encrypt=True, qop=None):
        return self.context.wrap(data, encrypt=encrypt, qop=qop)

    def wrap_iov(self, iov, encrypt=True, qop=None):
        return self.context.wrap_iov(iov, encrypt=encrypt, qop=qop)

    def unwrap(self, data):
        return self.context.unwrap(data)

    def unwrap_iov(self, iov):
        return self.context.unwrap_iov(iov)

    def sign(self, data, qop=None):
        return self.context.sign(data, qop=qop)

    def verify(self, data, mic):
        return self.context.verify(data, mic)

    def convert_channel_bindings(self, bindings):
        return self.context.convert_channel_bindings(bindings)

    def get_context_attribute_value(self, name):
        return self.context.get_context_attribute_value(name)

    def reset_ntlm_crypto_state(self, outgoing=True):
        return self.context.reset_ntlm_crypto_state(outgoing=outgoing)
